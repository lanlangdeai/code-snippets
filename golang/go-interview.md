# golang面试题



1. Go 语言中的并发安全性是什么？如何确保并发安全性？

解答：
并发安全性是指在并发编程中，多个 goroutine 对共享资源的访问不会导致数据竞争和不确定的结果。


为了确保并发安全性，可以采取以下措施：

使用互斥锁（Mutex）：通过使用互斥锁来保护共享资源的访问，一次只允许一个 goroutine 访问共享资源，从而避免竞争条件。
使用原子操作（Atomic Operations）：对于简单的读写操作，可以使用原子操作来保证操作的原子性，避免竞争条件。
使用通道（Channel）：通过使用通道来进行 goroutine 之间的通信和同步，避免共享资源的直接访问。
使用同步机制：使用同步机制如等待组（WaitGroup）、条件变量（Cond）等来协调多个 goroutine 的执行顺序和状态。


通过以上措施，可以确保并发程序的安全性，避免数据竞争和不确定的结果。


2. Go 语言中的 defer 关键字有什么作用？请给出一个使用 defer 的示例。

解答：
defer 关键字用于延迟函数的执行，即在函数退出前执行某个操作。
defer 通常用于释放资源、关闭文件、解锁互斥锁等清理操作，以确保在函数执行完毕后进行处理。

也可以使用 defer 语句结合 time 包实现函数执行时间的统计。

1) 被defer的函数的参数在执行到defer语句的时候就被确定下来了
```go
func a() {
    i := 0
    defer fmt.Println(i) // 最终打印0
    i++
    return
}
```
2) 被defer的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。
```go
 // f returns 42
func f() (result int) {
	defer func() {
		// result is accessed after it was set to 6 by the return statement
		result *= 7
	}()
	return 6
}
```


3. Go 语言中的指针有什么作用？请给出一个使用指针的示例。

解答：
指针是一种变量，存储了另一个变量的内存地址。通过指针，我们可以直接访问和修改变量的值，而不是对变量进行拷贝。


指针在传递大型数据结构和在函数间共享数据时非常有用。


4. Go 语言中的 map 是什么？请给出一个使用 map 的示例。

解答：
map 是一种无序的键值对集合，也称为字典。map 中的键必须是唯一的，而值可以重复。
map 提供了快速的查找和插入操作，适用于需要根据键快速检索值的场景。


5. map 是无序的，每次迭代 map 的顺序可能不同。如果需要按特定顺序遍历 map，应该怎么做呢？

解答：
在 Go 语言中，map 是无序的，每次迭代 map 的顺序可能不同。如果需要按特定顺序遍历 map，可以采用以下步骤：



1) 创建一个切片来保存 map 的键。
2) 遍历 map，将键存储到切片中。
3) 对切片进行排序。

根据排序后的键顺序，遍历 map 并访问对应的值。


6. Go 语言中的 slice 和数组有什么区别？请给出一个使用 slice 的示例。

解答：
在Go语言中，数组和切片（slice）都是用于存储一组相同类型的元素。它们的区别在于长度的固定性和灵活性。
数组的长度是固定的，而切片的长度是可变的。

需要注意的是，切片是基于数组的一种封装，它提供了更便捷的操作和灵活性。切片的底层是一个指向数组的指针，它包含了切片的长度和容量信息。

1) 数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变；切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度。
2) 数组的内存空间是在定义时分配的，其大小是固定的；切片的内存空间是在运行时动态分配的，其大小是可变的。
3) 当数组作为函数参数时，函数操作的是数组的一个副本，不会影响原始数组；当切片作为函数参数时，函数操作的是切片的引用，会影响原始切片。
4) 切片还有容量的概念，它指的是分配的内存空间。


7. Go 语言中make和new的使用场景?

1) make 是 golang 提供的关键字，主要是用于初始化内置的数据结构，不能初始化自定义的数据结构 ， make 可以初始化的数据类型有：
- slice 切片
- map hash表
- channel 通道
这三种类型的零值都是nil, 其中map,channel的零值无法正常使用, slice会自动扩容


如果是用于slice类型，make函数的第2个参数表示slice的长度，这个参数必须给值。


返回的是原始类型，也就是slice, map和chan，不是返回指向slice, map和chan的指针
make返回的是引用,是Type类型, new返回的是指针,是*Type类型

slice用make创建的时候，如果指定的长度len>0，则make创建的slice下标索引从0到len-1的值都是对应slice里元素类型的零值

2) new 可以初始化自定义的数据结构, 根据传入的类型分配一片内存空间并返回指向这片内存空间的指针

new可以初始化任意类型, 包括slice,map,channel
```go
// example1.go
package main

import "fmt"

func main() {
	a := *new([]int)
	fmt.Printf("%T, %v\n", a, a==nil)

	b := *new(map[string]int)
	fmt.Printf("%T, %v\n", b, b==nil)

	c := *new(chan int)
	fmt.Printf("%T, %v\n", c, c==nil)
}
```
虽然new可以用来创建slice, map和chan，但实际上并没有卵用，因为new创建的slice, map和chan的值都是零值，也就是nil。这3种类型如果是nil，那遇到的问题我们在上面第一个问题已经解答过了


总结:
a) 尽量不使用new
b) 对于slice, map和chan的定义和初始化，优先使用make函数



8. Go 语言中的 panic 和 recover 有什么作用？请给出一个使用 panic 和 recover 的示例。

解答：
panic 和 recover 是 Go 语言中用于处理异常的机制。当程序遇到无法处理的错误时，可以使用 panic 引发一个异常，中断程序的正常执行。
而 recover 用于捕获并处理 panic 引发的异常，使程序能够继续执行。

```go
package main

import "fmt"

func divide(a, b int) int {
  defer func() {
    if err := recover(); err != nil {
      fmt.Println("Error:", err)
    }
  }()

  if b == 0 {
    panic("division by zero")
  }
  
  return a / b
}

func main() {
  result := divide(10, 0)
  fmt.Println("Result:", result)
}

```

9. 什么是互斥锁（Mutex）？在 Go 语言中如何使用互斥锁来保护共享资源？

解答：
互斥锁是一种并发编程中常用的同步机制，用于保护共享资源的访问。

在 Go 语言中，可以使用 sync 包中的 Mutex 类型来实现互斥锁。通过调用 Lock 方法来获取锁，保护共享资源的访问，然后在使用完共享资源后调用 Unlock 方法释放锁。

```go
package main

import (
  "fmt"
  "sync"
)

var (
  counter int
  mutex   sync.Mutex
)

func increment() {
  mutex.Lock()
  counter++
  mutex.Unlock()
  
  // 原子操作, 系统级别
  // atomic.AddInt64(&Counter, 1)  
}

func main() {
  var wg sync.WaitGroup
  for i := 0; i < 1000; i++ {
    wg.Add(1)
    go func() {
      defer wg.Done()
      increment()
    }()
  }
  wg.Wait()

  fmt.Println("Counter:", counter)
}

```

10. 解释一下并发编程中的自旋状态？

解答：
自旋状态是并发编程中的一种状态，指的是线程或进程在等待某个条件满足时，不会进入休眠或阻塞状态，而是通过不断地检查条件是否满足来进行忙等待。

在自旋状态下，线程会反复执行一个忙等待的循环，直到条件满足或达到一定的等待时间。 这种方式可以减少线程切换的开销，提高并发性能。然而，自旋状态也可能导致 CPU 资源的浪费，因为线程会持续占用 CPU 时间片，即使条件尚未满足。


自旋状态通常用于以下情况：

在多处理器系统中，等待某个共享资源的释放，以避免线程切换的开销。
在短暂的等待时间内，期望条件能够快速满足，从而避免进入阻塞状态的开销。

需要注意的是，自旋状态的使用应该谨慎，并且需要根据具体的场景和条件进行评估。如果自旋时间过长或条件不太可能很快满足，那么使用自旋状态可能会浪费大量的 CPU 资源。在这种情况下，更适合使用阻塞或休眠等待的方式。

总之，自旋状态是一种在等待条件满足时不进入休眠或阻塞状态的并发编程技术。它可以减少线程切换的开销，但需要权衡 CPU 资源的使用和等待时间的长短。



11. 原子操作和锁的区别是什么？


原子操作和锁是并发编程中常用的两种同步机制，它们的区别如下：


作用范围：

原子操作（Atomic Operations）：原子操作是一种基本的操作，可以在单个指令级别上执行，保证操作的原子性。原子操作通常用于对共享变量进行读取、写入或修改等操作，以确保操作的完整性。
锁（Lock）：锁是一种更高级别的同步机制，用于保护临界区（Critical Section）的访问。锁可以用于限制对共享资源的并发访问，以确保线程安全。

使用方式：

原子操作：原子操作是通过硬件指令或特定的原子操作函数来实现的，可以直接应用于变量或内存位置，而无需额外的代码。
锁：锁是通过编程语言提供的锁机制来实现的，需要显式地使用锁的相关方法或语句来保护临界区的访问。

粒度：

原子操作：原子操作通常是针对单个变量或内存位置的操作，可以在非常细粒度的层面上实现同步。
锁：锁通常是针对一段代码或一组操作的访问进行同步，可以控制更大粒度的临界区。

性能开销：

原子操作：原子操作通常具有较低的性能开销，因为它们是在硬件级别上实现的，无需额外的同步机制。
锁：锁通常具有较高的性能开销，因为它们需要进行上下文切换和线程同步等操作。


综上所述，原子操作和锁是两种不同的同步机制，用于处理并发编程中的同步问题。原子操作适用于对单个变量的读写操作，具有较低的性能开销。而锁适用于对一段代码或一组操作的访问进行同步，具有更高的性能开销。选择使用原子操作还是锁取决于具体的场景和需求。

需要注意的是，原子操作通常用于对共享变量进行简单的读写操作，而锁更适用于对临界区的访问进行复杂的操作和保护。在设计并发程序时，需要根据具体的需求和性能要求来选择合适的同步机制。


12. GMP模型?

Golang的一大特色就是Goroutine。Goroutine是Golang支持高并发的重要保障。Golang可以创建成千上万个Goroutine来处理任务，将这些Goroutine分配、负载、调度到处理器上采用的是G-M-P模型。
什么是Goroutine
Goroutine = Golang + Coroutine。Goroutine是golang实现的协程，是用户级线程。Goroutine具有以下特点：

1) 相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右）
2) 能够动态地伸缩栈的大小，最大可以支持到Gb级别
3) 工作在用户态，切换成很小
4) 与线程关系是n:m，即可以在n个系统线程上多工调度m个Goroutine

G-M-P分别代表：

G - Goroutine，Go协程，是参与调度与执行的最小单位
M - Machine，指的是系统级线程
P - Processor，指的是逻辑处理器，P关联了的本地可运行G的队列(也称为LRQ)，最多可存放256个G。

GMP调度流程大致如下：

1) 线程M想运行任务就需得获取 P，即与P关联。
2) 然从 P 的本地队列(LRQ)获取 G
3) 若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，
4) 若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。
5) 拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。




13. Go 语言中的 goroutine 是什么？请给出一个使用 goroutine 的示例。

解答：
goroutine 是 Go 语言中轻量级的并发执行单元，可以同时执行多个 goroutine，而不需要显式地管理线程的生命周期。
goroutine 由 Go 运行时（runtime）进行调度，可以在并发编程中实现并行执行。



14. Go 语言中的通道（channel）是什么？请给出一个使用通道的示例。

解答：
通道是用于在 goroutine 之间进行通信和同步的机制。通道提供了一种安全的、阻塞的方式来发送和接收数据。通过通道，可以实现多个 goroutine 之间的数据传递和同步。

```go
package main

import "fmt"

func sum(a, b int, c chan int) {
    result := a + b
    c <- result // 将结果发送到通道
}

func main() {
    // 创建一个整型通道
    c := make(chan int)

    // 启动一个goroutine来计算两个数的和
    go sum(10, 20, c)

    // 从通道接收结果
    result := <-c

    fmt.Println("Sum:", result)
}

```


15. chan, 通道

channel 可以分为 3 种类型：

只读 channel，单向 channel
只写 channel，单向 channel

可读可写 channel

channel 还可按是否带有缓冲区分为：
带缓冲区的 channel，定义了缓冲区大小，可以存储多个数据
不带缓冲区的 channel，只能存一个数据，并且只有当该数据被取出才能存下一个数据




有缓冲chan
1) 关闭chan,仍然可以读取chan中的值
2) channel满了,发送者会阻塞
3) channel空了,接受者会阻塞
4) 若在同一goroutine中, 写操作一定要在读取操作之前





16. Go 语言中的 select 语句是什么？请给出一个使用 select 语句的示例。

解答：
select 语句是 Go 语言中用于处理通道操作的一种机制。它可以同时监听多个通道的读写操作，并在其中任意一个通道就绪时执行相应的操作。

```go
package main

import "fmt"

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    go func() {
        ch1 <- 10
    }()

    go func() {
        ch2 <- 20
    }()

    select {
    case num := <-ch1:
        fmt.Println("Received from ch1:", num)
    case num := <-ch2:
        fmt.Println("Received from ch2:", num)
    }
}


```




17. Go 语言中的 runtime 包是用来做什么的？请给出一个使用 runtime 包的示例。

解答：
runtime 包是 Go 语言的运行时系统，提供了与底层系统交互和控制的功能。它包含了与内存管理、垃圾回收、协程调度等相关的函数和变量。




18. Go 语言中的垃圾回收是如何工作的？请给出一个使用垃圾回收的示例。

解答：
Go 语言中的垃圾回收器（Garbage Collector）是自动管理内存的机制，用于回收不再使用的内存。垃圾回收器会自动检测不再使用的对象，并释放其占用的内存空间。


19. 接口类型


接口是一种引用类型的数据结构，它的值可以为nil。
实现接口的类型必须实现接口中所有的方法，否则会编译错误。
接口的值可以赋给实现接口的类型的变量，反之亦然。
在实现接口的类型的方法中，可以通过类型断言来判断接口值的实际类型和值。



20. Go有引用变量和引用传递么？


Go语言里没有引用变量和引用传递。






































































